## design mode

### 1. 简单工厂模式

通过工厂实例化对象，运用对象调用方法达到对不同功能的实现

### 2. 策略模式

创建策略类，包含实际对象，实际对象中的方法。使用时通过创建策略类对象，达到实际调用功能。

> 简单工厂和策略模式区别：
>
> 简单工厂直接操作实际对象，需要让客户端认识两个类：工厂类和产品类的父类
>
> 策略模式对外提供策略类间接操作实际对象，客户端只需要认识一个类context

### 3. 单一职责原则

就一个类而言，应该仅有一个引起他它变化的原因[ASD]

### 4. 开放-封闭原则

对于拓展开放，对于更改封闭

### 5. 依赖倒转原则

1. 抽象不依赖细节，细节依赖于抽象（高层模块不依赖低层模块，两个都依赖抽象）。
2. 针对接口编程， 不对实现编程。

### 6. 里氏替换原则

子类型必须能替换掉父类型，即继承复用的实现原理

### 7. 装饰模式

动态地给一个对象添加一些额外的职责，就增加功能来说，装饰模式比生成子类更为灵活。

实现：装饰抽象类中定义具体对象，装饰实现类实现具体对象的抽象方法，达到装饰效果

### 8. 代理模式

为其他对象提供一种代理以控制对这个对象的访问。

实现：代理类中定义被代理对象及其方法，通过代理类调用被代理对象的方法，隐藏真实操作对象。

### 9. 工厂方法模式

定义一个用于创建对象的接口，让子类决定实例化哪一个类。

工厂方法使一个类的实例化延迟到其他子类。[DP]

### 10. 原型模式

用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。[DP]

### 11. 模板方法模式

定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。

模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。[DP]

### 12. 迪米特法则（最少知道法则）

如果两个类不必彼此直接通信，那么这两个类就不应当发生直接的相互作用。如果其中一个类需要调用另一个类的某一个方法的话，可以通过第三方转发这个调用。

### 13. 外观模式

为子系统中的一组接口提供一个一致的界面，此模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。[DP]

### 14. 建造者模式

使用多个简单的对象一步一步构建成一个复杂的对象。 提供了一种创建对象的最佳方式。 

 一个 Builder 类会一步一步构造最终的对象。该 Builder 类是独立于其他对象的。 

### 15. 观察者模式

定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态发生变化时，会通知所有观察者对象，使它们能够自动更新自己。 [DP]

### 16. 抽象工厂模式

提供一个创建一系列相关或相互依赖对象的接口，而无需指定他们具体的类。[DP0]